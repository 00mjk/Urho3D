$#include "Core/Variant.h"
$#include "IO/VectorBuffer.h"

enum VariantType
{
    VAR_NONE = 0,
    VAR_INT,
    VAR_BOOL,
    VAR_FLOAT,
    VAR_VECTOR2,
    VAR_VECTOR3,
    VAR_VECTOR4,
    VAR_QUATERNION,
    VAR_COLOR,
    VAR_STRING,
    VAR_BUFFER,
    VAR_VOIDPTR,
    VAR_RESOURCEREF,
    VAR_RESOURCEREFLIST,
    VAR_VARIANTVECTOR,
    VAR_VARIANTMAP,
    VAR_INTRECT,
    VAR_INTVECTOR2,
    VAR_PTR,
    VAR_MATRIX3,
    VAR_MATRIX3X4,
    VAR_MATRIX4,
    VAR_DOUBLE,
    VAR_STRINGVECTOR,
    MAX_VAR_TYPES
};

struct ResourceRef
{
    ResourceRef();
    ResourceRef(StringHash type);
    ResourceRef(StringHash type, String name);
    ResourceRef(const ResourceRef& rhs);
    ~ResourceRef();

    StringHash type_ @ type;
    String name_ @ name;

    bool operator == (const ResourceRef& rhs) const;
};

struct ResourceRefList
{
    ResourceRefList();
    ResourceRefList(StringHash type);
    ~ResourceRefList();

    StringHash type_ @ type;

    bool operator == (const ResourceRefList& rhs) const;
};

class Variant
{
    Variant();
    Variant(int value);
    Variant(unsigned value);
    Variant(const StringHash& value);
    Variant(bool value);
    Variant(float value);
    Variant(double value);
    Variant(const Vector2& value);
    Variant(const Vector3& value);
    Variant(const Vector4& value);
    Variant(const Quaternion& value);
    Variant(const Color& value);
    Variant(const String value);
    Variant(const char* value);
    tolua_outside void VariantConstructFromBuffer @ Variant(const VectorBuffer& value);
    Variant(void* value);
    Variant(const ResourceRef& value);
    Variant(const ResourceRefList& value);
    Variant(const Vector<Variant>& value);
//variantmap
    Variant(const Vector<String>& value);
    Variant(const IntRect& value);
    Variant(const IntVector2& value);
//refcounted*
    Variant(const Matrix3& value);
    Variant(const Matrix3x4& value);
    Variant(const Matrix4& value);
    Variant(const String type, const String value);
    Variant(VariantType type, const String value);
    Variant(const char* type, const char* value);
    Variant(VariantType type, const char* value);
    Variant(const Variant& value);
    ~Variant();

    void Clear();

    bool operator ==(const Variant& rhs) const;
    bool operator ==(int rhs) const;
    bool operator ==(unsigned rhs) const;
    bool operator ==(bool rhs) const;
    bool operator ==(float rhs) const;
    bool operator ==(double rhs) const;
    bool operator ==(const Vector2& rhs);
    bool operator ==(const Vector3& rhs) const;
    bool operator ==(const Vector4& rhs) const;
    bool operator ==(const Quaternion& rhs) const;
    bool operator ==(const Color& rhs) const;
    bool operator ==(const String rhs) const;
    tolua_outside bool VariantEqualWithBuffer @ operator ==(const VectorBuffer& rhs) const;
//void*
    bool operator ==(const ResourceRef& rhs) const;
    bool operator ==(const ResourceRefList& rhs) const;
    bool operator ==(const Vector<Variant>& rhs) const;
//variantmap
    bool operator ==(const Vector<String>& rhs) const;
    bool operator ==(const IntRect& rhs) const;
    bool operator ==(const IntVector2& rhs) const;
    bool operator ==(const StringHash& rhs) const;
//refcounted*
    bool operator ==(const Matrix3& rhs) const;
    bool operator ==(const Matrix3x4& rhs) const;
    bool operator ==(const Matrix4& rhs) const;

    int GetInt() const;
    unsigned GetUInt() const;
    StringHash GetStringHash();
    bool GetBool() const;
    float GetFloat() const;
    double GetDouble() const;
    const Vector2& GetVector2() const;
    const Vector3& GetVector3() const;
    const Vector4& GetVector4() const;
    const Quaternion& GetQuaternion() const;
    const Color& GetColor() const;
    const String GetString() const;
    tolua_outside VectorBuffer VariantGetBuffer @ GetBuffer() const;
//void*
    const ResourceRef& GetResourceRef() const;
    const ResourceRefList& GetResourceRefList() const;
    const Vector<Variant>& GetVariantVector() const;
//variantmap
    const Vector<String>& GetStringVector() const;
    const IntRect& GetIntRect() const;
    const IntVector2& GetIntVector2() const;
//refcounted*
    const Matrix3& GetMatrix3() const;
    const Matrix3x4& GetMatrix3x4() const;
    const Matrix4& GetMatrix4() const;

    VariantType GetType() const;
    String GetTypeName() const;
    String ToString() const;
    bool IsZero() const;
    bool IsEmpty() const;

    tolua_readonly tolua_property__get_set VariantType type;
    tolua_readonly tolua_property__get_set String typeName;
    tolua_readonly tolua_property__is_set bool zero;
    tolua_readonly tolua_property__is_set bool empty;
};

${

static void VariantConstructFromBuffer(Variant* variant, const VectorBuffer& value)
{
    *variant = value.GetBuffer();
}

static bool VariantEqualWithBuffer(const Variant* variant, const VectorBuffer& rhs)
{
    return variant->operator ==(rhs.GetBuffer());
}

static VectorBuffer VariantGetBuffer(const Variant* variant)
{
    return VectorBuffer(variant->GetBuffer());
}

$}

class VariantMap
{
    VariantMap();
    ~VariantMap();

    static void _SetupIndex(const char* type);
};

$[
    -- Call the setup method and then hide it immediately
    VariantMap:_SetupIndex("VariantMap")
    VariantMap:_SetupIndex("const VariantMap")
    VariantMap._SetupIndex = nil
$]

${

static int VariantMapIndexEvent (lua_State* tolua_S)
{
    int t = lua_type(tolua_S, 2);
    StringHash key;
    if (t == LUA_TSTRING)
        key = StringHash(lua_tostring(tolua_S, 2));
    else if (t == LUA_TNUMBER)
        key = StringHash(lua_tonumber(tolua_S, 2));
    else
    {
        lua_pushnil(tolua_S);
        return 1;
    }
    Variant* variant = static_cast<const VariantMap*>(tolua_tousertype(tolua_S, 1, 0))->operator [](key);
    if (variant)
        tolua_pushusertype(tolua_S, variant, "Variant");
    else
        lua_pushnil(tolua_S);
    return 1;
}

static int VariantMapNewIndexEvent (lua_State* tolua_S)
{
    int t = lua_type(tolua_S, 2);
    StringHash key;
    if (t == LUA_TSTRING)
        key = StringHash(lua_tostring(tolua_S, 2));
    else if (t == LUA_TNUMBER)
        key = StringHash(lua_tonumber(tolua_S, 2));
    else
        return 0;
    Variant& variant = static_cast<VariantMap*>(tolua_tousertype(tolua_S, 1, 0))->operator [](key);     // autovivification
    switch (lua_type(tolua_S, 3))   // Use the type of lua object to determine the final variant type
    {
    case LUA_TNIL:
        variant = Variant::EMPTY;
        break;

    case LUA_TBOOLEAN:
        variant = (bool)lua_toboolean(tolua_S, 3);     // Still need to cast to bool as Lua/LuaJIT return it as int
        break;

    case LUA_TNUMBER:
        {
            // Use the original variant type to further determine the final variant type
            // CAVEAT:
            // If lhs has integral data type and double is desired then lhs needs to be reset first before assigning
            double value = lua_tonumber(tolua_S, 3);
            switch (variant.GetType())
            {
            case VAR_INT:
                variant = (int)value;
                break;

            case VAR_BOOL:
                variant = value != 0.0f;
                break;

            case VAR_FLOAT:
                variant = (float)value;
                break;

            default:
                variant = value;
            }
        }
        break;

    case LUA_TSTRING:
        variant = lua_tostring(tolua_S, 3);
        break;

    case LUA_TUSERDATA:
    case LUA_TLIGHTUSERDATA:
    case LUA_TTABLE:
    case LUA_TFUNCTION:
    case LUA_TTHREAD:
        printf("TODO: VariantMapIndexEvent does not yet support Lua type %d", lua_type(tolua_S, 3));
        break;
    }
    return 0;
}

#define TOLUA_DISABLE_tolua_CoreLuaAPI_VariantMap__SetupIndex00
static int tolua_CoreLuaAPI_VariantMap__SetupIndex00(lua_State* tolua_S)
{
#ifndef TOLUA_RELEASE
 tolua_Error tolua_err;
 if (
 !tolua_isusertable(tolua_S,1,"VariantMap",0,&tolua_err) ||
 !tolua_isstring(tolua_S,2,0,&tolua_err) ||
 !tolua_isnoobj(tolua_S,3,&tolua_err)
 )
 goto tolua_lerror;
 else
#endif
 {
  const char* type = ((const char*)  tolua_tostring(tolua_S,2,0));
 {
  // Register our own version of metamethod to handle index and new-index events
  luaL_getmetatable(tolua_S, type);
  lua_pushstring(tolua_S, "__index");
  lua_pushcfunction(tolua_S, VariantMapIndexEvent);
  lua_rawset(tolua_S, -3);
  lua_pushstring(tolua_S, "__newindex");
  lua_pushcfunction(tolua_S, VariantMapNewIndexEvent);
  lua_rawset(tolua_S, -3);
  lua_pop(tolua_S, 1);
 }
 }
 return 0;
#ifndef TOLUA_RELEASE
 tolua_lerror:
 tolua_error(tolua_S,"#ferror in function '_SetupIndex'.",&tolua_err);
 return 0;
#endif
}

$}
